package generator

import (
	"text/template"
)

var source = template.Must(template.New("generated").
	Funcs(template.FuncMap{
		"lcFirst": lcFirst,
	}).
	Parse(`
// Code generated by github.com/oreqizer/go-relaygen, DO NOT EDIT.

package {{ .Package }}

import "github.com/oreqizer/go-relaygen/relay"

/*
{{ .Name }}Edge is an interface holding a node and a cursor

https://facebook.github.io/relay/graphql/connections.htm#sec-Edge-Types
*/
type {{ .Name }}Edge struct {
	Node *{{ .Name }} ` + "`" + `json:"node"` + "`" + `
	Cursor string ` + "`" + `json:"cursor"` + "`" + `
}

/*
{{ .Name }}Connection holds information about a connection

https://facebook.github.io/relay/graphql/connections.htm#sec-Reserved-Types
*/
type {{ .Name }}Connection struct {
	Edges    []*{{ .Name }}Edge  ` + "`" + `json:"edges"` + "`" + `
	PageInfo relay.PageInfo ` + "`" + `json:"pageInfo"` + "`" + `
}

/*
{{ .Name }}ConnectionFromArray creates a connection from an array of nodes
*/
func {{ .Name }}ConnectionFromArray(nodes []*{{ .Name }}, args *relay.ConnectionArgs) *{{ .Name }}Connection {
	if args == nil {
		return nil
	}

	edges := make([]*{{ .Name }}Edge, len(nodes))
	for i, n := range nodes {
		edges[i] = &{{ .Name }}Edge{
			Node:   n,
			Cursor: n.ID(),
		}
	}

	return {{ .Name|lcFirst }}EdgesToReturn(edges, args.Before, args.After, args.First, args.Last)
}

/*
{{ .Name|lcFirst }}EdgesToReturn slices edges according to arguments, returning a connection

Consider returning an error like in
https://facebook.github.io/relay/graphql/connections.htm#sec-Pagination-algorithm
*/
func {{ .Name|lcFirst }}EdgesToReturn(all []*{{ .Name }}Edge, before, after *string, first, last *int) *{{ .Name }}Connection {
	edges := {{ .Name|lcFirst }}ApplyCursorsToEdges(all, before, after)

	if first != nil && *first > 0 && *first < len(edges) {
		edges = edges[:*first]
	}

	if last != nil && *last > 0 && *last < len(edges) {
		edges = edges[len(edges)-*last:]
	}

	var startCursor, endCursor *string
	if len(edges) > 0 {
		if fst := edges[0]; fst != nil {
			str := fst.Cursor
			startCursor = &str
		}

		if lst := edges[len(edges)-1]; lst != nil {
			str := lst.Cursor
			endCursor = &str
		}
	}

	return &{{ .Name }}Connection{
		Edges: edges,
		PageInfo: relay.PageInfo{
			HasPreviousPage: {{ .Name|lcFirst }}HasPreviousPage(all, before, after, last),
			HasNextPage:     {{ .Name|lcFirst }}HasNextPage(all, before, after, first),
			StartCursor:     startCursor,
			EndCursor:       endCursor,
		},
	}
}

/*
{{ .Name|lcFirst }}ApplyCursorsToEdges slices edges according to cursors
*/
func {{ .Name|lcFirst }}ApplyCursorsToEdges(all []*{{ .Name }}Edge, before, after *string) []*{{ .Name }}Edge {
	edges := all
	if after != nil {
		for i, e := range edges {
			if e.Cursor == *after {
				edges = edges[i:]
				break
			}
		}
	}

	if before != nil {
		for i, e := range edges {
			if e.Cursor == *before {
				edges = edges[:i+1]
				break
			}
		}
	}
	return edges
}

/*
{{ .Name|lcFirst }}HasPreviousPage determines whether there's a previous page according to cursors

https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo.Fields
*/
func {{ .Name|lcFirst }}HasPreviousPage(all []*{{ .Name }}Edge, before, after *string, last *int) bool {
	if last != nil && *last > 0 {
		edges := {{ .Name|lcFirst }}ApplyCursorsToEdges(all, before, after)
		return len(edges) > *last
	}

	return false
}

/*
{{ .Name|lcFirst }}HasNextPage determines whether there's another page according to cursors

https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo.Fields
*/
func {{ .Name|lcFirst }}HasNextPage(all []*{{ .Name }}Edge, before, after *string, first *int) bool {
	if first != nil && *first > 0 {
		edges := {{ .Name|lcFirst }}ApplyCursorsToEdges(all, before, after)
		return len(edges) > *first
	}

	return false
}
`))
